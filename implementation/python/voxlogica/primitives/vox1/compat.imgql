// VoxLogicA experimental compatibility library.
//
// This module is auto-exported when importing namespace "vox1".
// It maps dot-based operators and derived helpers to Python kernels.

let ./.(a,b) = num_div(a,b)
let .*.(a,b) = num_mul(a,b)
let .+.(a,b) = num_add(a,b)
let .-.(a,b) = num_sub(a,b)
let .&.(a,b) = bool_and_scalar(a,b)
let .|.(a,b) = bool_or_scalar(a,b)
let !.(a) = bool_not_scalar(a)
let .=.(a,b) = num_eq(a,b)
let .<=.(a,b) = num_leq(a,b)
let .<.(a,b) = num_lt(a,b)
let .>=.(a,b) = num_geq(a,b)
let .>.(a,b) = num_gt(a,b)

let .= (n,i) = eq_sv(n,i)
let .<= (n,i) = geq_sv(n,i)
let .>= (n,i) = leq_sv(n,i)
let ./ (n,i) = div_sv(n,i)
let .- (n,i) = sub_sv(n,i)
let /. (i,n) = div_vs(i,n)
let -. (i,n) = sub_vs(i,n)
let +. (i,n) = add_vs(i,n)
let *. (i,n) = mul_vs(i,n)

let &(a,b) = and(a,b)
let |(a,b) = or(a,b)
let !(a) = not(a)
let ~>(a,b) = through(b,a)
let N(a) = near(a)
let I(a) = interior(a)
let B+(a) = (near(a)) \ a

let \(a,b) = and(a,not(b))

let mayReach(a,b) = N((b ~> N(a)) | a)
let touch(a,b) = a ~> N(b)
let grow(a,b) = (a | touch(b,a))
let T(a,b) = touch(a,b)

let surrounded(a,b) = a \ mayReach(not(a | b),not(b))
let S(a,b) = surrounded(a,b)

let .< (n,i) = (n .<= i) & (!(n .= i))
let .> (n,i) = (n .>= i) & (!(n .= i))
let <. (i,n) = n .> i
let <=. (i,n) = n .>= i
let >. (i,n) = n .< i
let >=. (i,n) = n .<= i
let =. (i,n) = n .= i

let .* (a,b) = b *. a
let .+ (a,b) = b +. a

let pdt(x) = mask(dt(x),dt(x) >. 0)
let distgeq(x,y) = x .<= pdt(y)
let distleq(x,y) = x .>= pdt(y)
let smoothen(a,x) = distleq(x,distgeq(x,!(a)))

let ~ (a,b,rad,bins) = crossCorrelation(rad,a,b,tt,min(b),max(b),bins)

let booleanToNumber(k,x) = mask(constant(k),x)
let norm(k,x) = (k .* x) /. max(x)

let ifB(cond,th,el) = or(and(th,bconstant(cond)),and(el,not(bconstant(cond))))
let ifN(cond,th,el) = mask(th,bconstant(cond)) + mask(el,not(bconstant(cond)))

let maskCC(phi1,phi2) = mask(Lcc(phi2),phi1)
let minCC(phi1,phi2) = min(maskCC(phi1,phi2))
let maxCC(phi1,phi2) = max(maskCC(phi1,phi2))

let collect(phi1,phi2) = (vol(phi1) .=. 0) | ((minCC(phi1,phi2) .=. maxCC(phi1,phi2)) & (maxCC(phi1,phi2) .>. 0))

let emptyB(phi) = volume(phi) .=. 0
let nemptyB(phi) = volume(phi) .>. 0

let xor(phi1,phi2) = (phi1 & !(phi2)) | (phi2 & !(phi1))
let eqB(phi1,phi2) = emptyB(xor(phi1,phi2))
let neqB(phi1,phi2) = nemptyB(xor(phi1,phi2))
let leqB(phi1,phi2) = emptyB(phi1 & !(phi2))

let overlayB(boolean,maskfalse,masktrue) = mask(masktrue,boolean) + mask(maskfalse,!(boolean))
let overlayColor(boolean,img,r,g,b) = rgb(overlayB(boolean,red(img),constant(r)),overlayB(boolean,green(img),constant(g)),overlayB(boolean,blue(img),constant(b)))

let divZ(i1,i2,i3) = mask((i1 / mask(constant(1),!(i2 =. 0))),!(i2 =. 0)) + (mask(i3,i2 =. 0))

let erode(a,x) = !(distleq(x,!(a)))
let dilate(a,x) = distleq(x,a)
let imopen(a,x) = dilate(erode(a,x),x)
let imclose(a,x) = erode(dilate(a,x),x)
